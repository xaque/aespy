#!/usr/bin/env python3

import numpy as np
import aes


## Finite field arithmetic tests
assert(aes.ffAdd(0x57,0x83) == 0xd4)
assert(aes.xtime(0x57) == 0xae)
assert(aes.xtime(0xae) == 0x47)
assert(aes.xtime(0x47) == 0x8e)
assert(aes.xtime(0x8e) == 0x07)
assert(aes.ffMultiply(0x57,0x13) == 0xfe)
assert(aes.ffMultiply(0x13,0x57) == 0xfe)


## State transformation tests
state0 = np.zeros([4, 4], dtype=np.int8)
state0[0][0] = 0x19
state0[0][1] = 0xa0
state0[0][2] = 0x9a
state0[0][3] = 0xe9
state0[1][0] = 0x3d
state0[1][1] = 0xf4
state0[1][2] = 0xc6
state0[1][3] = 0xf8
state0[2][0] = 0xe3
state0[2][1] = 0xe2
state0[2][2] = 0x8d
state0[2][3] = 0x48
state0[3][0] = 0xbe
state0[3][1] = 0x2b
state0[3][2] = 0x2a
state0[3][3] = 0x08

state1 = np.zeros([4, 4], dtype=np.int8)
state1[0][0] = 0xd4
state1[0][1] = 0xe0
state1[0][2] = 0xb8
state1[0][3] = 0x1e
state1[1][0] = 0x27
state1[1][1] = 0xbf
state1[1][2] = 0xb4
state1[1][3] = 0x41
state1[2][0] = 0x11
state1[2][1] = 0x98
state1[2][2] = 0x5d
state1[2][3] = 0x52
state1[3][0] = 0xae
state1[3][1] = 0xf1
state1[3][2] = 0xe5
state1[3][3] = 0x30
aes.subBytes(state0)
assert((aes.subBytes(state0) == state1).all())


state2 = np.zeros([4, 4], dtype=np.int8)
state2[0][0] = 0xd4
state2[0][1] = 0xe0
state2[0][2] = 0xb8
state2[0][3] = 0x1e
state2[1][0] = 0xbf
state2[1][1] = 0xb4
state2[1][2] = 0x41
state2[1][3] = 0x27
state2[2][0] = 0x5d
state2[2][1] = 0x52
state2[2][2] = 0x11
state2[2][3] = 0x98
state2[3][0] = 0x30
state2[3][1] = 0xae
state2[3][2] = 0xf1
state2[3][3] = 0xe5
aes.shiftRows(state1)
assert((aes.shiftRows(state1) == state2).all())


state3 = np.zeros([4, 4], dtype=np.int8)
state3[0][0] = 0x04
state3[0][1] = 0xe0
state3[0][2] = 0x48
state3[0][3] = 0x28
state3[1][0] = 0x66
state3[1][1] = 0xcb
state3[1][2] = 0xf8
state3[1][3] = 0x06
state3[2][0] = 0x81
state3[2][1] = 0x19
state3[2][2] = 0xd3
state3[2][3] = 0x26
state3[3][0] = 0xe5
state3[3][1] = 0x9a
state3[3][2] = 0x7a
state3[3][3] = 0x4c
aes.mixColumns(state2)
assert((aes.mixColumns(state2) == state3).all())


state4 = np.zeros([4, 4], dtype=np.int8)
state4[0][0] = 0xa4
state4[0][1] = 0x68
state4[0][2] = 0x6b
state4[0][3] = 0x02
state4[1][0] = 0x9c
state4[1][1] = 0x9f
state4[1][2] = 0x5b
state4[1][3] = 0x6a
state4[2][0] = 0x7f
state4[2][1] = 0x35
state4[2][2] = 0xea
state4[2][3] = 0x50
state4[3][0] = 0xf2
state4[3][1] = 0x2b
state4[3][2] = 0x43
state4[3][3] = 0x49

key1 = np.zeros([4, 4], dtype=np.int8)
key1[0][0] = 0xa0
key1[0][1] = 0x88
key1[0][2] = 0x23
key1[0][3] = 0x2a
key1[1][0] = 0xfa
key1[1][1] = 0x54
key1[1][2] = 0xa3
key1[1][3] = 0x6c
key1[2][0] = 0xfe
key1[2][1] = 0x2c
key1[2][2] = 0x39
key1[2][3] = 0x76
key1[3][0] = 0x17
key1[3][1] = 0xb1
key1[3][2] = 0x39
key1[3][3] = 0x05
aes.addRoundKey(state3, key1)
assert((aes.addRoundKey(state3, key1) == state4).all())


## Key expansions tests

assert(aes.ssubWord(0x00102030) == 0x63cab704)
assert(aes.ssubWord(0x40506070) == 0x0953d051)
assert(aes.ssubWord(0x8090a0b0) == 0xcd60e0e7)
assert(aes.ssubWord(0xc0d0e0f0) == 0xba70e18c)

assert(aes.rrotWord(0x09cf4f3c) == 0xcf4f3c09)
assert(aes.rrotWord(0x2a6c7605) == 0x6c76052a)

key0 = np.zeros([4, 4], dtype=np.int8)
key0[0][0] = 0x2b
key0[0][1] = 0x28
key0[0][2] = 0xab
key0[0][3] = 0x09
key0[1][0] = 0x7e
key0[1][1] = 0xae
key0[1][2] = 0xf7
key0[1][3] = 0xcf
key0[2][0] = 0x15
key0[2][1] = 0xd2
key0[2][2] = 0x15
key0[2][3] = 0x4f
key0[3][0] = 0x16
key0[3][1] = 0xa6
key0[3][2] = 0x88
key0[3][3] = 0x3c
aes.nextRoundKey(key0, 1)
assert((aes.nextRoundKey(key0, 1) == key1).all())

key2 = np.zeros([4, 4], dtype=np.int8)
key2[0][0] = 0xf2
key2[0][1] = 0x7a
key2[0][2] = 0x59
key2[0][3] = 0x73
key2[1][0] = 0xc2
key2[1][1] = 0x96
key2[1][2] = 0x35
key2[1][3] = 0x59
key2[2][0] = 0x95
key2[2][1] = 0xb9
key2[2][2] = 0x80
key2[2][3] = 0xf6
key2[3][0] = 0xf2
key2[3][1] = 0x43
key2[3][2] = 0x7a
key2[3][3] = 0x7f
aes.nextRoundKey(key1, 2)
assert((aes.nextRoundKey(key1, 2) == key2).all())

key = np.array([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
				0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c], dtype=np.int8)

expanded = [0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c,
            0xa0fafe17, 0x88542cb1, 0x23a33939, 0x2a6c7605,
            0xf2c295f2, 0x7a96b943, 0x5935807a, 0x7359f67f,
            0x3d80477d, 0x4716fe3e, 0x1e237e44, 0x6d7a883b,
            0xef44a541, 0xa8525b7f, 0xb671253b, 0xdb0bad00,
            0xd4d1c6f8, 0x7c839d87, 0xcaf2b8bc, 0x11f915bc,
            0x6d88a37a, 0x110b3efd, 0xdbf98641, 0xca0093fd,
            0x4e54f70e, 0x5f5fc9f3, 0x84a64fb2, 0x4ea6dc4f,
            0xead27321, 0xb58dbad2, 0x312bf560, 0x7f8d292f,
            0xac7766f3, 0x19fadc21, 0x28d12941, 0x575c006e,
            0xd014f9a8, 0xc9ee2589, 0xe13f0cc8, 0xb6630ca6]

key192 = np.array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17], dtype=np.int8)

expanded192 = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
			   0x10111213, 0x14151617, 0x5846f2f9, 0x5c43f4fe,
			   0x544afef5, 0x5847f0fa, 0x4856e2e9, 0x5c43f4fe,
			   0x40f949b3, 0x1cbabd4d, 0x48f043b8, 0x10b7b342,
			   0x58e151ab, 0x04a2a555, 0x7effb541, 0x6245080c,
			   0x2ab54bb4, 0x3a02f8f6, 0x62e3a95d, 0x66410c08,
			   0xf5018572, 0x97448d7e, 0xbdf1c6ca, 0x87f33e3c,
			   0xe5109761, 0x83519b69, 0x34157c9e, 0xa351f1e0,
			   0x1ea0372a, 0x99530916, 0x7c439e77, 0xff12051e,
			   0xdd7e0e88, 0x7e2fff68, 0x608fc842, 0xf9dcc154,
			   0x859f5f23, 0x7a8d5a3d, 0xc0c02952, 0xbeefd63a,
			   0xde601e78, 0x27bcdf2c, 0xa223800f, 0xd8aeda32,
			   0xa4970a33, 0x1a78dc09, 0xc418c271, 0xe3a41d5d]

key256 = np.array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
				 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f], dtype=np.int8)

expanded256 = [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
			   0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f,
			   0xa573c29f, 0xa176c498, 0xa97fce93, 0xa572c09c,
			   0x1651a8cd, 0x0244beda, 0x1a5da4c1, 0x0640bade,
			   0xae87dff0, 0x0ff11b68, 0xa68ed5fb, 0x03fc1567,
			   0x6de1f148, 0x6fa54f92, 0x75f8eb53, 0x73b8518d,
			   0xc656827f, 0xc9a79917, 0x6f294cec, 0x6cd5598b,
			   0x3de23a75, 0x524775e7, 0x27bf9eb4, 0x5407cf39,
			   0x0bdc905f, 0xc27b0948, 0xad5245a4, 0xc1871c2f,
			   0x45f5a660, 0x17b2d387, 0x300d4d33, 0x640a820a,
			   0x7ccff71c, 0xbeb4fe54, 0x13e6bbf0, 0xd261a7df,
			   0xf01afafe, 0xe7a82979, 0xd7a5644a, 0xb3afe640,
			   0x2541fe71, 0x9bf50025, 0x8813bbd5, 0x5a721c0a,
			   0x4e5a6699, 0xa9f24fe0, 0x7e572baa, 0xcdf8cdea,
			   0x24fc79cc, 0xbf0979e9, 0x371ac23c, 0x6d68de36]

assert(aes.rrotWord(0xff000000) == 0xff)
assert(aes.rrotWord(0x0e000000) == 0x0e)
assert(aes.rrotWord(0x12345678) == 0x34567812)
assert(aes.expandKey(key) == expanded)
assert(aes.expandKey(key192) == expanded192)
assert(aes.expandKey(key256) == expanded256)




## Appendix B cipher tests

state = np.array([[0x19,0xa0,0x9a,0xe9],
                  [0x3d,0xf4,0xc6,0xf8],
                  [0xe3,0xe2,0x8d,0x48],
                  [0xbe,0x2b,0x2a,0x08]], dtype=np.int8)

sub = np.array([[0xd4,0xe0,0xb8,0x1e],
                [0x27,0xbf,0xb4,0x41],
                [0x11,0x98,0x5d,0x52],
                [0xae,0xf1,0xe5,0x30]], dtype=np.int8)

shift = np.array([[0xd4, 0xe0, 0xb8, 0x1e],
                  [0xbf, 0xb4, 0x41, 0x27],
                  [0x5d, 0x52, 0x11, 0x98],
                  [0x30, 0xae, 0xf1, 0xe5]], dtype=np.int8)

mix = np.array([[0x04, 0xe0, 0x48, 0x28],
                [0x66, 0xcb, 0xf8, 0x06],
                [0x81, 0x19, 0xd3, 0x26],
                [0xe5, 0x9a, 0x7a, 0x4c]], dtype=np.int8)

rounds = np.array([[0xa4, 0x68, 0x6b, 0x02],
                   [0x9c, 0x9f, 0x5b, 0x6a],
                   [0x7f, 0x35, 0xea, 0x50],
                   [0xf2, 0x2b, 0x43, 0x49]], dtype=np.int8)

key = np.array([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
				0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c], dtype=np.int8)
key = key.transpose()

assert((aes.subBytes(state) == sub).all())
assert((aes.shiftRows(sub) == shift).all())
assert((aes.mixColumns(shift) == mix).all())
keystate = np.zeros([4, 4], dtype=np.int8)
for i in range(4):
    for j in range(4):
        keystate[i][j] = key[i*4 + j]
keystate = keystate.transpose()
assert((aes.addRoundKey(mix, aes.nextRoundKey(keystate, 1)) == rounds).all())



in1 = np.array([0x32, 0x43, 0xf6, 0xa8,
				0x88, 0x5a, 0x30, 0x8d,
				0x31, 0x31, 0x98, 0xa2,
				0xe0, 0x37, 0x07, 0x34], dtype=np.int8)

result = np.array([0x39, 0x25, 0x84, 0x1d,
				   0x02, 0xdc, 0x09, 0xfb,
				   0xdc, 0x11, 0x85, 0x97,
				   0x19, 0x6a, 0x0b, 0x32], dtype=np.int8)

output = aes.cipher(in1, key)
assert((output == result).all())

deoutput = aes.invCipher(output, key)
assert((deoutput == in1).all())


## Appendix C tests

input1 = np.array([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
				   0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], dtype=np.int8)
key1 = np.array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f], dtype=np.int8)
output1 = np.array([0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
					0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a], dtype=np.int8)

input2 = input1
key2 = np.array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17], dtype=np.int8)
output2 = np.array([0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0,
					0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91], dtype=np.int8)

input3 = input1
key3 = np.array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
				 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f], dtype=np.int8)
output3 = np.array([0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
					0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89], dtype=np.int8)

actual1 = aes.cipher(input1, key1)
assert((actual1 == output1).all())
deinput1 = aes.invCipher(actual1, key1)
assert((deinput1 == input1).all())

actual2 = aes.cipher(input2, key2)
assert((actual2 == output2).all())
deinput2 = aes.invCipher(actual2, key2)
assert((deinput2 == input2).all())

actual3 = aes.cipher(input3, key3)
assert((actual3 == output3).all())
deinput3 = aes.invCipher(actual3, key3)
assert((deinput3 == input3).all())

print("All tests passed")